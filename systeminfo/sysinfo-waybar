#!/bin/env python
"""
Formatting wrapper around system monitoring daemons
"""

import argparse
import json
import re
import sys
import subprocess

class Memoize:
    """ Decorator to memoize function calls """
    def __init__(self, fn):
        self.fun = fn
        self.memo = {}

    def __call__(self, *args):
        if args not in self.memo:
            self.memo[args] = self.fun(*args)
        return self.memo[args]

# Status bar colors: base16-default-dark
COLOR = {
    'base00': '181818',
    'base01': '282828',
    'base02': '383838',
    'base03': '585858',
    'base04': 'b8b8b8',
    'base05': 'd8d8d8',
    'base06': 'e8e8e8',
    'base07': 'f8f8f8',
    'base08': 'ab4642',
    'base09': 'dc9656',
    'base0A': 'f7ca88',
    'base0B': 'a1b56c',
    'base0C': '86c1b9',
    'base0D': '7cafc2',
    'base0E': 'ba8baf',
    'base0F': 'a16946'
}

@Memoize
def get_color(inp):
    """ Function to return a color string """
    # Define the colors as given by base16, and by their names
    named = {
        'background': COLOR['base01'],
        'bkg': COLOR['base01'],
        'muted': COLOR['base03'],
        'mute': COLOR['base03'],
        'foreground': COLOR['base04'],
        'frg': COLOR['base04'],
        'red': COLOR['base08'],
        'crimson': COLOR['base08'],
        'ora': COLOR['base09'],
        'orange': COLOR['base09'],
        'yel': COLOR['base0A'],
        'yellow': COLOR['base0A'],
        'gre': COLOR['base0B'],
        'green': COLOR['base0B'],
        'cya': COLOR['base0C'],
        'cyan': COLOR['base0C'],
        'ind': COLOR['base0D'],
        'blue': COLOR['base0D'],
        'indigo': COLOR['base0D'],
        'vio': COLOR['base0E'],
        'pink': COLOR['base0E'],
        'violet': COLOR['base0E'],
        'purple': COLOR['base0E'],
        'bro': COLOR['base0F'],
        'brown': COLOR['base0F']}
    colors = {**COLOR, **named}
    # Do answer checking
    if re.search(r'^(?:[0-9a-fA-F]{3}){1,2}$', inp):
        return inp
    if inp in colors:
        return colors[inp]
    if re.search(r'^#(?:[0-9a-fA-F]{3}){1,2}$', inp):
        return inp
    print('Invalid color selection, defaulting to red')
    return colors['red']

if __name__ == '__main__':
    # Parse inputs
    PRSR = argparse.ArgumentParser('Modules to print system info')
    PRSR.add_argument('name', help="Daemon name to run", type=str)
    PRSR.add_argument('-a', '--accent', help="Accent type if requested", type=str)
    NSPC = PRSR.parse_args()

    # Get requested method
    METHOD = vars(NSPC)['name']

    # Create formatting dict
    FORM = {'format': '',
            'prefix': '',
            'suffix': '',
            'mute': False,
            'class': ''}

    # Check if accent was an argument
    if not vars(NSPC)['accent'] is None:
        TEXT = "<span color='#{accent}'>{prefix}</span>"
        TEXT += "{format}"
        TEXT += "<span color='#{accent}'>{suffix}</span>"
        FORM['accent'] = get_color(vars(NSPC)['accent'])
    else:
        TEXT = '{prefix}{format}{suffix}'

    # Create output dict
    OUT = {'text': '', 'class': ''}

    # Start the daemon
    DAEMON = subprocess.Popen(sys.path[0] + '/' + METHOD,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.DEVNULL)
    while True:
        # Read all lines as json until termination
        LINE = DAEMON.stdout.readline()
        # Exit if terminated
        if not LINE:
            break
        # Read input
        NEW = json.loads(LINE.decode('utf-8'))
        # Load onto the formatting dict
        FORM = {**FORM, **NEW}
        # If both the prefix and format are empty, skip
        if FORM['prefix'] == '' and FORM['suffix'] == '' and FORM['format'] == '':
            print('{}')
            sys.stdout.flush()
            continue
        # Set mute css class, if takes precedent
        if FORM['mute']:
            OUT['class'] = 'mute'
        else:
            OUT['class'] = FORM['class']
        if 'accent' in FORM:
            FORM['accent'] = get_color(FORM['accent'])
        # Format string
        OUT['text'] = TEXT.format_map(FORM)
        print(json.dumps(OUT, ensure_ascii=False))
        # Flush stdout
        sys.stdout.flush()
