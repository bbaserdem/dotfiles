#!/bin/env python
"""
Formatting wrapper around system monitoring daemons
"""

import argparse
import json
import os
import re
import sys
import subprocess
import threading

# Status bar colors: base16-default-dark
COLOR = {
    'base00': '181818',
    'base01': '282828',
    'base02': '383838',
    'base03': '585858',
    'base04': 'b8b8b8',
    'base05': 'd8d8d8',
    'base06': 'e8e8e8',
    'base07': 'f8f8f8',
    'base08': 'ab4642',
    'base09': 'dc9656',
    'base0A': 'f7ca88',
    'base0B': 'a1b56c',
    'base0C': '86c1b9',
    'base0D': '7cafc2',
    'base0E': 'ba8baf',
    'base0F': 'a16946'
}

def get_color(inp):
    """ Function to return a color string """
    # Define the colors as given by base16, and by their names
    named = {
        'background': COLOR['base01'],
        'bkg': COLOR['base01'],
        'muted': COLOR['base03'],
        'mute': COLOR['base03'],
        'foreground': COLOR['base04'],
        'frg': COLOR['base04'],
        'red': COLOR['base08'],
        'crimson': COLOR['base08'],
        'ora': COLOR['base09'],
        'orange': COLOR['base09'],
        'yel': COLOR['base0A'],
        'yellow': COLOR['base0A'],
        'gre': COLOR['base0B'],
        'green': COLOR['base0B'],
        'cya': COLOR['base0C'],
        'cyan': COLOR['base0C'],
        'ind': COLOR['base0D'],
        'blue': COLOR['base0D'],
        'indigo': COLOR['base0D'],
        'vio': COLOR['base0E'],
        'pink': COLOR['base0E'],
        'violet': COLOR['base0E'],
        'purple': COLOR['base0E'],
        'bro': COLOR['base0F'],
        'brown': COLOR['base0F']}
    colors = {**COLOR, **named}
    # Do answer checking
    if re.search(r'^(?:[0-9a-fA-F]{3}){1,2}$', inp):
        return inp
    if inp in colors:
        return colors[inp]
    if re.search(r'^#(?:[0-9a-fA-F]{3}){1,2}$', inp):
        return inp
    print('Invalid color selection, defaulting to red')
    return colors['red']

def get_opacity(inp=1):
    """ Function to parse opacity value """
    # Check if already hex
    if re.search(r'^(?:[0-9a-fA-F]{2})$', inp):
        return inp
    # Recast as a number just in case
    inp = float(inp)
    # Return empty string if no transparency
    if inp == 1:
        return ''
    # Get the hex as a string
    ans = hex(min(max(round(inp*255), 0), 255))[:2]
    ans = (2-len(ans))*'0' + ans
    return ans


def exec_shell_command(cmd):
    """ Function to run arbitrary shell command """
    subprocess.call(['/bin/dash', '-c', cmd],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL)

def environ_or_required(key, default):
    if os.environ.get(key):
        return os.environ.get(key)
    else:
        return default

class BarInfo:
    """ Main class that contains common bar information """
    def __init__(self):
        # Initialize default variables
        self.text = ''
        # Initialize the fields that will transform the format
        self.format = {
            'format' : '',
            'accent' : get_color('red'),
            'foreground' : '',
            'background' : get_color('background'),
            'opacity' : get_opacity('1.0'),
            'prefix' : '',
            'suffix' : '',
            'on-click' : 'true',
            'on-click-right' : 'true',
            'on-click-middle' : 'true',
            'on-scroll-up' : 'true',
            'on-scroll-down' : 'true',
            'mute' : False}
        self.dimmed = get_color('muted')
        self.bright = get_color('frg')
        self.module = ''

    def display(self):
        """ Method to print information out, must be defined individually """
        sys.stdout.flush()

    def launch(self):
        """ Execute the main daemon, and collect info from it continuously"""
        prc = subprocess.Popen(sys.path[0] + '/' + self.module,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.DEVNULL)
        while True:
            # Read all lines as json until termination
            output = prc.stdout.readline()
            # Exit if terminated
            if not output:
                break
            # Read input
            self.read(json.loads(output.decode('utf-8')))
            # Print output
            self.display()

    def read(self, info):
        """ Read a dictionary, and overwrite stuff """
        # Overload info
        self.format = {**self.format, **info}
        # Change foreground color depending on context
        if self.format['mute']:
            self.format['foreground'] = self.dimmed
        else:
            self.format['foreground'] = self.bright
        # Redo accent color
        self.format['accent'] = get_color(self.format['accent'])

# Print to Polybar
class PolyBarInfo(BarInfo):
    """ Class to retain lemonbar formatting
        POLYBAR FORMATTING
            Transparency is given by
                #AAXXXXXX
            Colors are set by:
                %{F#XXXXXX} text %(F-}
            Background is set by %{B}
                %{B#XXXXXX} text %{B-}
            Colors can be reversed with %{R}
            Actions are set as
                %{AN:command: AM:command:} %{A A}
                1: left click
                2: middle click
                3: right click
                4: scroll up
                5: scroll down
                6: double left click
                7: double middle click
                8: double right click
            Underline is set by
                %{u#XXXXXX +u} text %{-u u-}
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Set actions
        self.text += ('%{{A1:{on-click}: ' +
                      'A2:{on-click-middle}: A3:{on-click-right}: ' +
                      'A4:{on-scroll-up}: A5:{on-scroll-down}:}}')
        # Set colors, foreground, background and underline
        self.text += '%{{B#{opacity}{background} u#{accent} +u}}'
        # Display prefix
        self.text += '%{{F#{accent}}}{prefix}%{{F-}}'
        # Text display
        self.text += '%{{F#{foreground}}}{format}%{{F-}}'
        # Display postfix
        self.text += '%{{F#{accent}}}{suffix}%{{F-}}'
        # Finalize text formatting
        self.text += '%{{B- -u u-}}'
        # Finalize action formatting
        self.text += '%{{A A A A A}}'

    def display(self):
        # Correct the action strings for lemonbar tags
        self.format['on-click'] = self.format['on-click'].replace(':', r'\:')
        self.format['on-click-right'] = self.format['on-click-right'].replace(':', r'\:')
        self.format['on-click-middle'] = self.format['on-click-middle'].replace(':', r'\:')
        self.format['on-scroll-up'] = self.format['on-scroll-up'].replace(':', r'\:')
        self.format['on-scroll-down'] = self.format['on-scroll-down'].replace(':', r'\:')
        # Print the formatted line
        print(self.text.format_map(self.format))
        # Call the generic method
        BarInfo.display(self)

# Read responses from i3bar
def i3_respond(stdin, form):
    """ Respond to stdin """
    for line in stdin:
        try:
            button = json.loads(line)['button']
            if button == 1:
                exec_shell_command(form['on-click'])
            elif button == 2:
                exec_shell_command(form['on-click-right'])
            elif button == 3:
                exec_shell_command(form['on-click-middle'])
            elif button == 4:
                exec_shell_command(form['on-scroll-up'])
            elif button == 5:
                exec_shell_command(form['on-scroll-down'])
        except:
            pass

class I3BarInfo(BarInfo):
    """ Class to output JSON format for i3blocks
    I3 FORMATTINC
        i3bar protocol uses the following fields.
        (Only full_text needs to be updated)
            'full_text' : '',
            'border': True,
            'min_width': 0,
            'align': 'left',
            'name': 'ticker',
            'instance': 'testing',
            'urgent': False,
            'seperator_block_width': 1,
            'markup': 'pango'
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Define the formatting for i3bar protocol (color and background set)
        self.jlist = {
            'color' : self.bright,
            'full_text' : '',
            'short_text' : self.module,
            'min_width' : 0,
            'align' : 'left',
            'urgent' : False,
            'seperator' : True,
            'seperator_block_width' : 1,
            'markup' : 'pango'}
        # Display prefix
        self.text += "<span color='#{accent}'>{prefix}</span>"
        self.text += "{format}"
        self.text += "<span color='#{accent}'>{suffix}</span>"
        self.listen = False
        self.thread = 0

    def display(self):
        """ Modify the jsonlist to be sent to i3bar """
        self.jlist = {**self.jlist, **self.format}
        self.jlist['color'] = '#' + self.format['foreground']
        self.jlist['background'] = '#' + self.format['background'] + self.format['opacity']
        self.jlist['full_text'] = self.text.format_map(self.format)
        out = json.dumps(self.jlist, ensure_ascii=False)
        print(out)
        # Call the generic method
        BarInfo.display(self)

    def read(self, info):
        """ Overload the reading method to start the listener """
        BarInfo.read(self, info)
        if not self.listen:
            self.listen = True
            self.thread = threading.Thread(target=i3_respond,
                                           args=(sys.stdin, self.format,),
                                           daemon=True)
            self.thread.start()

# Print to waybar
class WayBarInfo(BarInfo):
    """ Class to output JSON format for i3blocks
        WAYBAR FORMATTING
            waybar uses the following fields:
            only text needs to be updated
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Define the formatting for i3bar protocol (color and background set)
        self.jlist = {
            'color' : self.bright,
            'background' : self.format['background'],
            'text' : '',
            'format' : '{}',
            'tooltip' : False}

        # Display prefix
        self.text += "<span color='#{accent}'>{prefix}</span>"
        self.text += "{format}"
        self.text += "<span color='#{accent}'>{suffix}</span>"

    def display(self):
        self.jlist = {**self.jlist, **self.format}
        # Custom theme
        self.jlist['color'] = self.format['foreground']
        self.jlist['background'] = '#' + self.format['background'] + self.format['opacity']
        self.jlist['format'] = self.text.format_map(self.format)
        self.jlist['text'] = self.text.format_map(self.format)
        out = json.dumps(self.jlist, ensure_ascii=False)
        print(out)
        # Call the generic method
        BarInfo.display(self)

if __name__ == '__main__':
    # Parse inputs
    PRSR = argparse.ArgumentParser('Modules to print system info')

    PRSR.add_argument('-a', '--accent', help="Specify accent color",
                      default=environ_or_required('accent', 'foreground'))
    PRSR.add_argument('-m', '--method', help="Specify output program",
                      default=environ_or_required('method', 'polybar'))
    PRSR.add_argument('-t', '--transparency', help="Specify bkg transparency",
                      default=environ_or_required('transparency', '1.0'))
    PRSR.add_argument('-n', '--name', help="Daemon name to run", type=str,
                      default=environ_or_required('name', 'audio'))
    NSPC = PRSR.parse_args()

    # Get requested method
    METHOD = vars(NSPC)['method']
    # Create a bar object, depending on the method variable
    if METHOD == 'polybar':
        MYBAR = PolyBarInfo()
    elif METHOD in ('i3bar', 'i3'):
        MYBAR = I3BarInfo()
    elif METHOD == 'waybar':
        MYBAR = WayBarInfo()
    else:
        print('Defaulting to polybar style . . .')
        MYBAR = PolyBarInfo()
    # Write colors
    MYBAR.format['accent'] = get_color(vars(NSPC)['accent'])
    MYBAR.format['opacity'] = get_opacity(vars(NSPC)['transparency'])
    # Set the module for the bar
    MYBAR.module = vars(NSPC)['name']

    # Start the bar
    MYBAR.launch()
