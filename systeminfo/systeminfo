#!/bin/env python
"""
Formatting wrapper around system monitoring daemons
"""

import argparse
import json
import os
import re
import sys
import subprocess
from threading import Thread

def exec_shell_command(cmd):
    """ Function to run arbitrary shell command """
    subprocess.call(['/bin/dash', '-c', cmd],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL)

# Get opacity hex string
def get_opacity(inp=1):
    """ Function to parse opacity value """
    # Check if already hex
    if re.search(r'^(?:[0-9a-fA-F]{2})$', inp):
        return inp
    inp = float(inp)
    if inp == 1:
        return ''
    ans = hex(min(max(round(inp*255), 0), 255))[:2]
    ans = (2-len(ans))*'0' + ans
    return ans

class BarInfo:
    """ Main class that contains common bar information """
    def __init__(self):
        # Initialize default variables
        self.text = ''
        # Initialize the fields that will transform the format
        self.format = {
            'format' : '',
            'accent' : 'ffffff',
            'foreground' : 'ffffff',
            'background' : '000000',
            'opacity' : get_opacity(1.0),
            'prefix' : '',
            'suffix' : '',
            'on-click-left' : 'true',
            'on-click-right' : 'true',
            'on-click-middle' : 'true',
            'on-scroll-up' : 'true',
            'on-scroll-down' : 'true',
            'mute' : False}
        # Check if there is a listener function
        self.listen = False

    def display(self):
        """ Method to print information out, must be defined individually """
        sys.stdout.flush()

    def launch(self):
        """ Execute the main daemon, and collect info from it continuously"""
        prc = subprocess.Popen(sys.path[0] + self.module,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.DEVNULL)
        while True:
            # Read all lines as json until termination
            output = prc.stdout.readline()
            if not output:
                break
            inp = json.loads(output)
            # Overload this dict on top of the existing one
            self.format = {**self.format, **inp}
            # Apply foreground color depending on context
            if self.format['mute']:
                self.format['foreground'] = self.mute
            else:
                self.format['foreground'] = self.foreground
            # Start listener if defined and not started yet
            if self.listen:
                self.listen.start()
                self.listen = False
            # Print output
            self.display()

# Print to console
class ConsoleInfo(BarInfo):
    """ Class to format to console """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Rename color
        self.format['color'] = ANSI[get_config('color', fallback='red')]
        # Set text style
        self.text += ANSI['bold'] + '{color}{prefix}' + ANSI['reset']
        self.text += '{format}'
        self.text += ANSI['bold'] + '{color}{suffix}' + ANSI['reset']

    def display(self):
        print(self.text.format_map(self.format))
        # Call the generic method
        BarInfo.display(self)






# Print to Polybar
class PolyBarInfo(BarInfo):
    """ Class to retain lemonbar formatting
        POLYBAR FORMATTING
            Colors are set by:
                %{F#XXXXXX} text %(F-}
            Background is set by %{B}
                %{B#XXXXXX} text %{B-}
            Colors can be reversed with %{R}
            Actions are set as
                %{AN:command: AM:command:} %{A A}
                1: left click
                2: middle click
                3: right click
                4: scroll up
                5: scroll down
                6: double left click
                7: double middle click
                8: double right click
            Underline is set by
                %{u#XXXXXX +u} text %{-u u-}
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Set actions
        self.text += ('%{{A1:{on-click-left}: ' +
                'A2:{on-click-middle}: A3:{on-click-right}: ' +
                'A4:{on-scroll-up}: A5:{on-scroll-down}:}}')
        # Set colors, foreground, background and underline
        self.text += '%{{B#{opacity}{background} u#{accent} +u}}'
        # Display prefix
        self.text += '%{{F#{accent}}}{prefix}%{{F-}}'
        # Text display
        self.text += '%{{F#{foreground}}}{format}%{{F-}}'
        # Display postfix
        self.text += '%{{F#{accent}}}{suffix}%{{F-}}'
        # Finalize text formatting
        self.text += '%{{B- -u u-}}'
        # Finalize action formatting
        self.text += '%{{A A A A A}}'

    def display(self):
        # Correct the action strings for lemonbar tags
        self.format['on-click-left'] = self.format['on-click-left'].replace(':', r'\:')
        self.format['on-click-right'] = self.format['on-click-right'].replace(':', r'\:')
        self.format['on-click-middle'] = self.format['on-click-middle'].replace(':', r'\:')
        self.format['on-scroll-up'] = self.format['on-scroll-up'].replace(':', r'\:')
        self.format['on-scroll-down'] = self.format['on-scroll-down'].replace(':', r'\:')
        # Print the formatted line
        print(self.text.format_map(self.format))
        # Call the generic method
        BarInfo.display(self)







# Print to i3bar
def i3_respond(stdin, form):
    """ Respond to stdin """
    for line in stdin:
        button = json.loads(line)['button']
        if button == 1:
            exec_shell_command(form['on-click-left'])
        elif button == 2:
            exec_shell_command(form['on-click-right'])
        elif button == 3:
            exec_shell_command(form['on-click-middle'])
        elif button == 4:
            exec_shell_command(form['on-scroll-up'])
        elif button == 5:
            exec_shell_command(form['on-scroll-down'])

class I3BarInfo(BarInfo):
    """ Class to output JSON format for i3blocks
    I3 FORMATTINC
        i3bar protocol uses the following fields.
        (Only full_text needs to be updated)
            'full_text' : '',
            'border': True,
            'min_width': 0,
            'align': 'left',
            'name': 'ticker',
            'instance': 'testing',
            'urgent': False,
            'seperator_block_width': 1,
            'markup': 'pango'
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Define the formatting for i3bar protocol (color and background set)
        self.jlist = {
            'color' : '',
            'full_text' : '',
            'short_text' : self.module,
            'min_width' : 0,
            'align' : 'left',
            'urgent' : False,
            'seperator' : True,
            'seperator_block_width' : 1,
            'markup' : 'pango'}
        # Display prefix
        self.text += "<span color='{accent}'>{prefix}</span>"
        self.text += "{format}"
        self.text += "<span color='{accent}'>{suffix}</span>"
        self.listen = Thread(target=i3_respond, args=(sys.stdin, self.format,))

    def display(self):
        """ Modify the jsonlist to be sent to i3bar """
        self.jlist = {**self.jlist, **self.format}
        self.jlist['color'] = self.format['foreground']
        self.jlist['full_text'] = self.text.format_map(self.format)
        print(json.dumps(self.jlist))
        # Call the generic method
        BarInfo.display(self)





# Print to waybar
class WayBarInfo(BarInfo):
    """ Class to output JSON format for i3blocks
        WAYBAR FORMATTING
            waybar uses the following fields:
            only text needs to be updated
    """
    def __init__(self):
        # Initialize fo the main class
        BarInfo.__init__(self)
        # Define the formatting for i3bar protocol (color and background set)
        self.jlist = {
            'color' : self.foreground,
            'background' : self.format['background'],
            'text' : '',
            'format' : '{}',
            'tooltip' : False}

        # Display prefix
        self.text += "<span color='{accent}'>{prefix}</span>"
        self.text += "{format}"
        self.text += "<span color='{accent}'>{suffix}</span>"

    def display(self):
        self.jlist = {**self.jlist, **self.format}
        # Custom theme
        self.jlist['color'] = self.format['background']
        self.jlist['background'] = self.format['background']
        self.jlist['format'] = self.text.format_map(self.format)
        self.jlist['full_text'] = self.text.format_map(self.format)
        json.dumps(self.jlist)
        # Call the generic method
        BarInfo.display(self)


if __name__ == '__main__':
    x = bar_info_init()
    x.launch()
